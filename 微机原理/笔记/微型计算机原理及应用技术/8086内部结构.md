# 8086内部结构
![Alt text](picture\8086结构图.png)
## 总线接口单元 BIU
### 组成结构
#### 寄存器
CS:代码段寄存器
ES:附加数据段寄存器
SS:堆栈段寄存器
DS:数据段寄存器  
IP:指令指针寄存器(8086中等效于一般微处理器中PC)
#### 地址产生与总线控制逻辑
上述例子中,都是用16位地址空间(16根线,64KB)来寻址的(如间接寻址中BX和SP),实际上8086由20根线(1MB)可以给存储器寻址,如何解决?
将1MB空间分为多个逻辑段,每一个逻辑段最大64KB,这样就可以用16根线来寻址,也就出现了段地址
CS来提供代码段的段地址(例如:取指令所在单元的段地址由CS提供,取值地址在单元里面哪地址由IP提供)
> 简单来说,地址分为两个部分组成
> 1. 段地址,由段地址寄存器提供(16位)
> 2. 段内地址,相当于偏移量,后面章节会提到(16位)

由于我写程序时候只提供16位地址,现在想要得到20位地址,就应该需要一定运算,这个运算由地址产生于总线控制逻辑来进行运算
#### 指令队列寄存器 
类似于一般微处理器中IR(1个字节,8位),在8086中指令队列寄存器是6个字节(48位)的,相当于6个IR,没放满就一直取
> 对应8088而言,指令队列寄存器是4个字节的,其余完全相同
### BIU作用
主要负责从外部存储器中取指令(代码段),并将取回指令放回指令队列中
## 执行单元 EU
### 主要作用
主要负责从指令队列中获取指令,遵循**先进先出**原则,并对获取的指令进行译码分析(执行该指令)

## 执行周期
从此我们可以看出在8086中,取指令和执行指令操作的同时进行的,比一般微处理器中取-执行=取=执行效率要高

1. 第一个周期
BIU取指令,EU空闲
2. 第二个周期
BIU继续取指令,执行BIU上一个周期获取的指令
3. 第三个周期
重复2操作,并一致循环下去

什么时候BIU会停止取指令呢?
1. 队列取满
2. EU要使用总线(进行写操作)

|BIU|取指令|取指令|帮助EU进行操作|
|:---:|:---:|:---:|:---:|
|EU|空闲|执行指令|执行指令(要用总线)|
|BUS|忙|忙|忙|

也可以看出,相比于一般微处理器,8086总线利用率很高
### 组成结构
* 通用寄存器
编写程序就要用,所以叫通用寄存器
* ALU及标志寄存器FR
* 内部控制逻辑电路
## 8086中寄存器的组织结构
共有14个16位寄存器
### 通用寄存器
总共有8个
#### 数据寄存器
4个,均为16位,都可分为高8低8位两个寄存器来使用,有且仅有这8个8位寄存器
都可用于暂存数据,每一个都有特殊功能
AX:累加器,作为目的操作数 
BX:基址寄存器,对某程序单元的进行读写操作,段内16位基本地址由BX提供
CX:计数寄存器,循环时每循环一次**自动**减1,有指令相互配合
DX:数据寄存器,操作I/O时可做端口地址寄存器,不用中括号
#### 地址指针与变址寄存器
均为16位
##### 地址指针寄存器
SP:堆栈指针寄存器,提供堆栈操作中堆栈段**段内地址的偏移量**
> 注意:SS提供的是段地址

BP:基址指针寄存器,提供**段内地址偏移量**
>注意:BP所提供16位地址和BX提供16位地址不在同一个段内,BX默认在数据段,BP默认在堆栈段

MOV BX, 002H
MOV BP, 002H
MOV [BX], 34H 默认写到数据段(DS)
MOV [BP], 34H 默认写到堆栈段(SS)
若是想要让BP写到数据段:
MOV DS:[BP], 34H 强制写到数据段
> 这里的DS称为段超越前缀/段前缀,汇编时候会多一个前缀码
##### 变址寄存器
均为地址寄存器
SI:源变址寄存器
DI:目的变址寄存器
>注意:这两个默认找的都素数据段(DS)单元

SI和DI在字符串操作中(MOVS命令),指定好后运行会**自动**的变(加减),进行字符串操作,所以叫变址
### 段寄存器
段寄存器存的是**段地址**
CS:代码段寄存器
ES:附加数据段寄存器
SS:堆栈段寄存器
DS:数据段寄存器 
>注意:段寄存器操作系统会自己初始化

## 数据存放格式
### 字节型
>伪指令:告诉汇编怎么编译的

DB 12H,12,-12
字节型数据伪指令，连续三个单元分别放12H,0CH,F4H
>这里是将12，-12转为补码又换位16进制
### 字型
DW 5678H
低单元地址称字的地址，由于字占两个字节，8086里面都是以字节存储的，字的高位放到高地址单元，低位放到低地址单元

字单元地址为偶地址称对准的字单元，奇地址称未对准字单元
>8086CPU对对准字单元速度比未对准的快一倍

### 双字单元
DD 783H

## 存储器分段与物理地址形成
存储器为什么要分段？
64K寻不了1M的
### 存储器分段
每个逻辑段，最大64K字节，每个逻辑段起始地址必须能被16整除
### 物理地址PA
物理地址是该单元实际存在地址
**逻辑段的起始地址要求能被16整除**，一个逻辑段最大64K
例如:
0段起始地址00000H
1段起始地址00010H
2段起始地址00020H
>请注意，一个逻辑段最大可以划分64K字节，这里0段和1段之间间隔16字节，也就是说他俩之间存在重叠空间。同时对应1M空间可以划分出64K个逻辑段

### 逻辑地址
|段地址|段内偏移地址(段内有效地址EA)|逻辑地址|
|:---:|:---:|:---:|
|0000H|0000H|0000H:0000H|
|0000H|0001H|0000H:0001H|
|0002H|0000H|0002H:0000H|
|0000H|0020H|0000H:0020H|
|0001H|0010H|0001H:0010H|

注意：表格后三个虽然表示不同，但都是同一个物理地址00020H

#### 物理地址形成
$$
物理地址 = 段地址 \times 16 + 段内偏移地址
$$
$段地址\times 16$相当于段地址左移一位