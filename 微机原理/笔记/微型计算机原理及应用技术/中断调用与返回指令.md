# 中断调用与返回指令
## 中断源
### 外部中断源
* NMI引脚 
  无条件响应，外部非可屏蔽中断请求，上升沿有效
* INTR引脚 
  受到IF中断标志位控制，外部可屏蔽中断请求，上升沿有效
  IF = 1，CPU处于开中断状态，允许响应
### 内部中断源
1. 除法出错中断源
   除数为0或商溢出引起
2. 单步中断源
   TF = 1 时中断
3. INTO 溢出中断
```
    ADD AX, BX
    INTO 
```
这里的INTO是一条指令，如果OF = 1，即发生溢出则产生溢出中断
4. 断点中断源
断点中断(单字节中断)指令 INT3
5. INT N指令
## 中断类型号
用于识别中断源的号码0~255，最多可管理256级中断
* 除法错 0
* 单步中断 1
* 断点中断 3
* 溢出中断 4
* INT N
* NMI 2
* INTR 的中断类型号是不确定，必须外挂8259中断控制芯片进行管理

## 中断向量
中断服务程序的入口地址(32位 = 16位段地址 + 16位偏移地址)
```
总断请求 INT
中断现场 MOV AX,BX
```
中断现场会把PSW(标志寄存器)，CS，IP的值依次压栈，称**现场保护**
然后中断后要转入的程序称为中断服务程序
### 中断向量表
把存储器中最低1024字节(00000H~003FFH)，作为中断向量表,里面存放中断向量，一个向量占用四个字节单元，从中断类型号0 ~256依次存放

$$N(中断类型号) \times 4 = 中断向量表中对应首地址$$
头两个单元存的是偏移地址，后两个单元存的是段地址
所以，在设计程序时，要把中断服务程序入口地址写在对应的中断向量表中存储器单元里，称中断向量的建立

中断服务程序最后一条指令是IRET，这样就可以把栈内的IP,CS,PSW依次出栈，给到相应的寄存器，恢复现场

## 中断响应
### 内部中断与外部非可屏蔽中断
1. 保护现场，依次入栈
2. 清除IF，目的是为了不会响应外部可屏蔽中断
3. TF清零，目的是不会单步执行
4. 查中断向量表，进入中断
5. 恢复中断现场
### 外部可屏蔽中断
1. IF = 1时，保护现场，依次入栈
2. 清除IF，目的是为了不会响应外部可屏蔽中断
3. TF清零，目的是不会单步执行
4. 从8259中断控制芯片中获取中断类型号
5. 8086给$\overline{INTA}$端口一个低电平脉冲，表明收到请求
6. 8086再给$\overline{INTA}$端口一个低电平脉冲，8259会把具体中断源的值送到数据线，8086同时读取
7. 恢复中断现场
>8086可以给8259 OUT出第一个位置上(IR0)的中断类型号，其余的依次加1

有N个8259芯片，级联在一切，可以管理$8\times N - N$个中断

## 系统功能调用
DOS操作系统(高级功能调用)INT 21H
BIOS(低级功能调用)INT 10H
### DOS功能调用
#### 输入一个字符
01H 等待用户从键盘输入一个字符，回显在屏幕当前光标处，被按键字符放在AL中，检测ctrl break
```nasm
MOV AH,01H
INT 21H; DOS功能调用,调用01H的功能
CMP AL,'1';看看输入的是不是1
```
07H 等待用户从键盘输入一个字符，被按键字符放在AL中，不检测ctrl break
08H 等待用户从键盘输入一个字符，被按键字符放在AL中，检测ctrl break
#### 输出一个字符
02H 向屏幕输出一个字符，被输出字符放在DL中
```nasm
MOV AH,02H
MOV DL,'5';被输出字符放在DL中
INT 21H
```
05H 向打印机输出一个字符，被输出字符放在DL中
```nasm
;回车换行子程序,回车是将光标放到最左端,换行是换到下一行
MOV AH,2
MOV DL,0DH;回车
INT 21H
MOV AH,2
MOV DL,0AH;换行
INT 21H
```
#### 直接控制台输入输出
06H 直接控制台输入输出
1. DL在00H~FEH之间，输出(屏幕上显示)
2. DL是FFH，输入(从键盘输入)，且**不等待**
```nasm
FUNC1:
  MOV AH,06H
  MOV DL,0FFH;输入
  INT 21H;若没按键ZF=1，有按键，ZF=0，按键放AL中
  JZ NAJ;有按键接着走，没按键跳到NAJ
  CMP AL,1BH;ESC键
  JE START;跳到程序最前，返回主菜单
  JMP FUNC1;不是ESC这个功能从做一遍
NAJ:
```
#### 输出一串字符
09H 向屏幕输出一串字符
```nasm
DATA SEGMENT
STRING DB '2.Find the max of string:','0DH','01H','$'
DATA ENDS
CODE SEGMENT
  ASSUME CS:CODE,DS:DATA;
START:
  MOV AX,DATA
  MOV DS,AX
  ;做好输出准备，即输出字符串段地址给DS，偏移地址给DX
  MOV AH,09H
  LEA DX,STRING
  INT 21H;最后的$是结束符,不显示,等同于C中\0
  MOV AH,4CH
  INT 21H
  CODE ENDS
END START
```
#### 输入一串字符
0AH 从键盘输入一串字符，有等待、回显功能
必须要定义键盘输入缓冲区
```nasm
DATA SEGMENT
KEYBUF1 DB 20H;允许用户输入的字符个数是20H个，最大能输入255个，键盘缓冲区从这里开始
        DB ?;保留,用于统计实际输入的字符个数(自动)
KEYBUF2 DB 20H DUP(?);定义了32个字节(8位)空间，存放实际使用字符串,定义标号是方便找
DATA ENDS
CODE SEGMENT
  ASSUME CS:CODE,DS:DATA
START:
  MOV AX,DATA
  MOV DS,AX
  ;做好输入准备，即缓冲区段地址给DS，偏移地址给DX
  MOV AH,0AH
  MOV DX,OFFSET KEBUF1
  INT 21H;等待输入，直到给回车结束，回车会放入缓冲区内，但被字符串长度不会算回车
  CODE ENDS
END START
```
#### 时间的设置与获取
2DH 时间设置
```nasm
MOV AH,2DH
MOV CH,时
MOV CL,分
MOV DH,秒
MOV DL,百分秒
INT 21H;AL=00设置成功，AL=FF设置失败
```
2CH 时间获取
```nasm
MOV AH,2CH
INT 21H;获取的时间放在上述寄存器中
```
### BIOS功能调用
00H 设置屏幕分辨率
02H 设置光标位置
```nasm
;设置屏幕分辨率
MOV AH,00H
MOV AL,3;设置成彩色文本模式，80×25，2000个字符
MOV BL,0;设置页号，第0页
INT 10H;一调用，就有清屏功能，光标回到左上角
;设置光标位置
MOV AH,02H
MOV DH,行
MOV DL,列
MOV BL,0;设置在0页，也可不写
INT 10H
```