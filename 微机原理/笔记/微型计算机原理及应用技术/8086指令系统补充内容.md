# 8086指令系统补充内容
## 标号
如：next:
标号一旦定义具有三个属性
1. 段地址属性
2. 段内偏移地址属性
3. 类型属性
  * NEAR 转译指令与专业标号在同一代码段，赋值-1
  * FAR  不在同一代码段，赋值-2

   
## 常数及表达式
### 常数
16进制常数：以H结尾
10进制常数：以D结尾，可不写
2进制常数：以B结尾
字符常数：单引号包含，如‘A’
字符串常数：双引号包含，如“Hello”
随机：？表示随机数，开机随机赋值
### 表达式
#### 算数表达式
mov 5+2*3
> 汇编出表达式的值，不是CPU计算的

#### 逻辑表达式
AND AL,21H AND OFH
后面的是逻辑表达式，也算汇编计算，不是CPU计算

#### 关系表达式
MOV AX,5 LT 3
> LT是小于,假取全0，真取全1

#### 属性表达式
获取标号段地址属性(16位)：SEG
获取标号段内偏移地址属性(16位)：OFFSET
获取标号类型属性：TYPE
>MOV BX,OFFSET NEXT
>获取NEXT标号的偏移地址放到BX

## 变量及定义变量伪指令
DB 定义字节型变量，8位，1个单元
DW 定义字型变量，16位，2个单元
DD 定义双字型变量，32位，4个单元
>DATE1 DB
在数据段定义DATE1变量，DATE1就相当于地址

变量一旦定义了，就具有五个属性
1. 该变量段地址属性 SEG
2. 该变量段内偏移地址属性 OFFSET
3. 该变量类型属性(字节型=1，字型=2) TYPE
4. 长度属性 LENGHT
5. 大小属性 SIZE

>MOV AL, TYPE DATE1 = MOVE AL,1

> \$ 是汇编程序中表示当前汇编到的存储器的地址
DW DATA2
可以用如MOV DATA2 $

用DB定义字符串时可定义无限长度的字符串，但是DW只能定义两个字符
> DATA2 DB 'hello'

DATA3 DW DATA2
这时候放的就是DATA2的OFFSET
DATA4 DD DATA2
这时候放的就是DATA2的OFFSET和SEG(偏移地址和段地址都放进去了)

DATA5 DB 4 DUP(?)
>DOP为重复操作符,随机赋值重复四次(连着4个单元都是随机数)

DATA5 DW 3 DUP(?)
>随机赋值重复三次(连着6个单元都是随机数)

### 长度属性
在变量名定义语句中所定义的变量个数，叫长度属性(LENGTH)
>出现了DUP,那么该变量长度属性就是重复的次数
>DATA2 没有出现DUP，长度就是1
>DATA5 为4 DATA4为3
### 大小属性
在变量名定义语句中，所定义的所有变量所占的总的字节数(单元数),叫大小属性
SIZE = TYPE * LENGTH
>DATA5 大小是4

DATA1 DB 01H
MOV AX, WORD PTR DATA1
>强制转换为字类型赋值给AX 

同理
MOV [BX], 10H
也会因为类型不明确而报错，不知道BX间接寻址应该放字节还是字
MOV BYTE PTR [BX], 10H
明确BX间接寻址是一个字节单元 
## 堆栈的注意事项
1. PUSH和POP只允许按字访问(16位)
2. 低字节放在偶地址，高字节放在低地址。**SP始终指向偶字节单元**
3. SP大小从FFFEH到0
4. PUSH后面不能接立即数，也不能POP CS因位CS不能作为目的操作数
5. POP是加，PUSH是减
## 数据传输指令简述
1. MOV
2. PUSH 与 POP
3. XCHG 数据交换指令 
   XCHG AL,BL 
   交换AL,BL的值
   >注意:段地址寄存器不能作为操作数(目的和源都不行)，两个存储单元也不能直接交换数据(不能XCHG [0001H],[0006H])
4. XLAT 换码指令
  将BX与AL内容相加作为EA，根据该偏移量找到对应内容送到AL中
5. LEA 将源操作数的有效地址EA送到目的操作数
   >注意:这里送的是偏移量，不是偏移量对应的值
   LEA DI,TABLE 本质上等同于 MOV DI,OFFSET TABLE
6. LDS 见P82
7. LES 见P82
8. 标志寄存器传送指令 见P82