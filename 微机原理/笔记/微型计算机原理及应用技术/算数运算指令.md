# 算数运算指令
* CPU只要进行运算，标志寄存器就会受到影响
* 段地址寄存器不参与运算
## 加法指令
1. ADD DST,SRC 
   不带进位加法，DST = (DST) + (SRC)同时设置状态标志
2. ADC DST,SRC
   带进位加法， DST = (DST) + (SRC) + CF(进位标志位)同时设置状态标志
3. INC 增1指令
   INC DST 
   DST = (DST) + 1同时设置状态标志(**除CF外,对CF没影响**)
## 减法指令
1. SUB DST,SRC
   不带借位减法，DST = (DST) - (SRC)同时设置状态标志
2. SBB
   带借位的减法， DST = (DST) - (SRC) - CF(进位标志位)同时设置状态标志
3. 减1指令
   DEC DST
   DST = (DST) - 1同时设置状态标志(**除CF外,对CF没影响**)
4. CMP 比较指令
   CMP DST,SRC
   (DST) - (SRC)，不影响源和目的操作数，**只是根据结果设置状态标志**
   主要是用于产生条件的(AF不算条件，但CMP会影响AF值)
5. NEG 求负指令
   NEG DST
   DST = 0 - (DST)同时设置状态标志

## 插入:条件转移指令
判断标志位然后转移的指令有:
>N表示Negative,J表示JUMP
* CF
     JC 标号
     JCN 标号
* SF
     JS 标号
     JNS 标号
* ZF
     JZ或JE 标号
     JNZ或JNE 标号
* PF
     JP 标号
     JNP 标号
* OF
     JO 标号
     JNO 标号

$\alpha,\beta$分别是无符号数，那么两数之间有如下关系:
1. 相等 E (不等是NE)
2. 高 A
3. 低 B

看CF标志位:
JB/JNAE 标号
JBE/JNA 标号

JA/JNBE 标号
JAE/JNB 标号
$\alpha,\beta$分别是有符号数，那么两数之间有如下关系:
1. 相等 E (不等是NE)
2. 大 G
3. 小 L

SF与OF异或，为1表明目的操作数小于源操作数:
JL/JNGE 标号
JLE/JNG 标号

JG/JNLE 标号
JGE/JNL 标号

## 乘法指令
注意事项:
1. **目的操作数是隐含的**，隐含是被操作数
2. 目的操作数**不能是立即数**，可以说存储器或寄存器
3. 加法减法指令部分带符号数和无符号数，但是乘除法指令取反有无符号
4. 字节乘与字乘与源操作数为准
5. 字节乘:AL 
积:AX
字乘:AX
积:DX:AX
### 无符号数乘法
MUL SRC
指令执行后，只影响CF,OF，其余状态标志**没定义**(状态不确定，随机的)
$CF=OF=0$
字节乘:说明AH高8位无效(都是0),只用管第八位就可
字乘:说明DX无效(都是0),只用管AX就可
$CF=OF=1$
有有效积

### 有符号数乘法
IMUL SRC
$CF=OF=0$
字节乘:说明AH高8位无效，AH的值是**AL符号位的扩展**
>AL最高位是符号位，AL最高位为0，AL全是0，为正；AL最高位为1，AL全是1，为负

字乘:说明DX无效，DX的值是**AX符号位的扩展**
$CF=OF=1$
有有效积
## 除法指令
1. **目的操作数是隐含的**，是被除数(前面的)
2. 目的操作数**不能是立即数**，可以说存储器或寄存器
3. 字节除:AX/8位，商在AL，余数在AH
字除:DX:AX/16位，商在AX，余数DX
4. 状态标志**均没定义**
### 无符号数除法
DIV SRC

### 带符号数除法
IDIV SRC
运算符号:
1. 被除数为正，除数为正，商为正，余数为正
2. 被除数为正，除数为负，商为正，余数为负
3. 被除数为负，除数为正，商为负，余数为负
4. 被除数为负，除数为负，商为正，余数为负

## 符号扩展指令
CBW (AL)扩展到(AX)中，AX内容是AL符号位扩展
CWD (AX)扩展到(DX)中，DX内容是AX符号位扩展
二者均**不影响状态标志**

## BCD数调整指令、
BCD数分为:
1. 分离BCD数
   8位表示一个十进制位，实际上只是用低4位对应一个十进制位，高4位任意
2. 组合BCD数
   放一起了，每4位对应一个十进制位

对于加减法而言，二者都可用，但乘除法只能用分离BCD数
对于加减乘，都是先运算，再调整；除法是先调整，后运算

### 加法BCD调整
组合:DAA
分离:AAA
二者都是对**AL**调整

### 减法BCD调整
组合:DAS
分离:AAS
二者都是对**AL**调整

### 乘法BCD调整
AAM 

### 乘法BCD调整
AAD

以上二者都是对**AX**调整
## 2进制数转10进制(BCD码)算法
除10取余算法
>除1次，余数为10进制数个位，商再除1次，余数为是10进制数十位，以此类推

BUFF1 放2进制数，BUFF2放转后的10进制(BCD码)
BUFF1 DB ?
BUFF2 DB DUP(?)

MOV AL, BUFF1
MOV AH, 0 (被除数是AX，要清零保证AX就是AL)
MOV CL, 10
DIV CL
MOV BUFF2, AH
MOV AH, 0
DIV CL
MOV BUFF2 + 1, AH
MOV BUFF2 + 2, AL
